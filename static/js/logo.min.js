const canvas = document.getElementById('pyramidCanvas');
if (!canvas) {
console.log('Pyramid logo canvas not found');
} else {
const ctx = canvas.getContext('2d');
const container = document.querySelector('.logo-container');
let isHovering = false;
let rotationX  = 0;
let rotationY  = 0;
const vertices = [
[0, 12, 0],
[-10, -8, -10],
[10, -8, -10],
[10, -8, 10],
[-10, -8, 10]
];
const edges = [
[0, 1], [0, 2], [0, 3], [0, 4],
[1, 2], [2, 3], [3, 4], [4, 1]
];
function getTextColor() {
return getComputedStyle(document.documentElement).getPropertyValue('--color-primary').trim();
}
function rotateX(point, angle) {
const cos = Math.cos(angle);
const sin = Math.sin(angle);
return [
point[0],
point[1] * cos - point[2] * sin,
point[1] * sin + point[2] * cos
];
}
function rotateY(point, angle) {
const cos = Math.cos(angle);
const sin = Math.sin(angle);
return [
point[0] * cos + point[2] * sin,
point[1],
-point[0] * sin + point[2] * cos
];
}
function project(point) {
const scale = 1.5;
return [
25 + point[0] * scale,
25 + point[1] * scale
];
}
function draw() {
ctx.clearRect(0, 0, 50, 50);
let transformedVertices = vertices.map(v => {
let point = [...v];
if (isHovering) {
point = rotateX(point, rotationX);
point = rotateY(point, rotationY);
}
return project(point);
});
ctx.strokeStyle = getTextColor();
ctx.lineWidth   = 2;
ctx.lineCap     = 'round';
edges.forEach(edge => {
const [start, end] = edge;
ctx.beginPath();
ctx.moveTo(transformedVertices[start][0], transformedVertices[start][1]);
ctx.lineTo(transformedVertices[end][0], transformedVertices[end][1]);
ctx.stroke();
});
}
function animate() {
if (isHovering) {
rotationX += 0.02;
rotationY += 0.03;
} else {
const easeSpeed = 0.00001;
rotationX += (0 - rotationX) * easeSpeed;
rotationY += (0 - rotationY) * easeSpeed;
if (Math.abs(rotationX) < 0.0001) rotationX = 0;
if (Math.abs(rotationY) < 0.0001) rotationY = 0;
}
draw();
requestAnimationFrame(animate);
}
container.addEventListener('mouseenter', () => {
isHovering = true;
});
container.addEventListener('mouseleave', () => {
isHovering = false;
});
animate();
}